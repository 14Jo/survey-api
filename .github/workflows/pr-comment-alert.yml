# .github/workflows/slack-notify.yml

name: Notify on PR Comment

on:
  issue_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  pull_request_review_comment:
    types: [created]

jobs:
  notify-slack:
    # 봇이 생성한 이벤트는 무시하고, PR과 관련된 이벤트에 대해서만 실행합니다.
    if: github.event.sender.type != 'Bot' && (github.event.issue.pull_request || github.event.pull_request)
    runs-on: ubuntu-latest

    steps:
      - name: Extract Info and Prepare Notification
        id: prepare
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
          EVENT_NAME: ${{ github.event_name }}
        run: |
          # ----------------------------------------------------------------
          # 1. 이벤트 종류에 따라 기본 변수 설정 및 알림 여부 결정
          # ----------------------------------------------------------------
          EVENT_TYPE=""
          COMMENT_BODY=""
          COMMENT_AUTHOR=""
          PR_API_URL=""
          COMMENT_HTML_URL=""
          
          if [[ "$EVENT_NAME" == "issue_comment" ]]; then
            # PR에 달린 일반 댓글
            COMMENT_BODY=$(echo "$EVENT_CONTEXT" | jq -r '.comment.body')
            # 댓글 내용이 없으면 알림을 보내지 않고 종료합니다.
            if [[ -z "$COMMENT_BODY" || "$COMMENT_BODY" == "null" ]]; then
              echo "Comment body is empty. Exiting."
              exit 0
            fi
          
            EVENT_TYPE="comment"
            COMMENT_AUTHOR=$(echo "$EVENT_CONTEXT" | jq -r '.comment.user.login')
            PR_API_URL=$(echo "$EVENT_CONTEXT" | jq -r '.issue.pull_request.url')
            COMMENT_HTML_URL=$(echo "$EVENT_CONTEXT" | jq -r '.comment.html_url')

          elif [[ "$EVENT_NAME" == "pull_request_review" ]]; then
            # PR 리뷰 (approved, changes_requested, commented)
            REVIEW_STATE=$(echo "$EVENT_CONTEXT" | jq -r '.review.state')
            COMMENT_BODY=$(echo "$EVENT_CONTEXT" | jq -r '.review.body')

            if [[ "$REVIEW_STATE" == "commented" ]]; then
              # 'commented' 상태일 경우, 리뷰에 달린 전체 코멘트 내용이 있는지 확인합니다.
              # 내용이 없으면 (보통 개별 라인 코멘트만 있는 경우), 중복/빈 알림을 막기 위해 무시합니다.
              if [[ -z "$COMMENT_BODY" || "$COMMENT_BODY" == "null" ]]; then
                echo "Review state is 'commented' and review body is empty. Ignoring."
                exit 0
              fi
              # 내용이 있으면 일반 코멘트로 처리합니다.
              EVENT_TYPE="comment"
            else
              # 'approved' 또는 'changes_requested' 상태로 설정합니다.
              # 이 경우, 코멘트 내용이 없어도 알림이 갑니다.
              EVENT_TYPE="$REVIEW_STATE"
            fi
          
            # 공통 변수들을 설정합니다.
            COMMENT_AUTHOR=$(echo "$EVENT_CONTEXT" | jq -r '.review.user.login')
            PR_API_URL=$(echo "$EVENT_CONTEXT" | jq -r '.pull_request.url')
            COMMENT_HTML_URL=$(echo "$EVENT_CONTEXT" | jq -r '.review.html_url')

          elif [[ "$EVENT_NAME" == "pull_request_review_comment" ]]; then
            # 코드 라인에 직접 달린 댓글
            COMMENT_BODY=$(echo "$EVENT_CONTEXT" | jq -r '.comment.body')
            # 댓글 내용이 없으면 알림을 보내지 않고 종료합니다.
            if [[ -z "$COMMENT_BODY" || "$COMMENT_BODY" == "null" ]]; then
              echo "Review comment body is empty. Exiting."
              exit 0
            fi
          
            EVENT_TYPE="comment"
            COMMENT_AUTHOR=$(echo "$EVENT_CONTEXT" | jq -r '.comment.user.login')
            PR_API_URL=$(echo "$EVENT_CONTEXT" | jq -r '.pull_request.url')
            COMMENT_HTML_URL=$(echo "$EVENT_CONTEXT" | jq -r '.comment.html_url')
          
            # 답글인 경우를 확인합니다.
            REPLY_TO_ID=$(echo "$EVENT_CONTEXT" | jq -r '.comment.in_reply_to_id')
            if [[ "$REPLY_TO_ID" != "null" ]]; then
              EVENT_TYPE="reply"
              ORIGINAL_COMMENT_URL="https://api.github.com/repos/${{ github.repository }}/pulls/comments/$REPLY_TO_ID"
              ORIGINAL_COMMENT_DATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$ORIGINAL_COMMENT_URL")
              ORIGINAL_COMMENT_AUTHOR=$(echo "$ORIGINAL_COMMENT_DATA" | jq -r '.user.login')
              ORIGINAL_COMMENT_BODY=$(echo "$ORIGINAL_COMMENT_DATA" | jq -r '.body')
          
              echo "original_comment_author=$ORIGINAL_COMMENT_AUTHOR" >> $GITHUB_OUTPUT
              echo "original_comment_body<<EOF" >> $GITHUB_OUTPUT
              echo "$ORIGINAL_COMMENT_BODY" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
          fi

          # ----------------------------------------------------------------
          # 2. PR 상세 정보 조회
          # ----------------------------------------------------------------
          if [[ -z "$PR_API_URL" || "$PR_API_URL" == "null" ]]; then
            echo "Could not determine PR API URL. Exiting."
            exit 1
          fi

          PR_DATA=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$PR_API_URL")
          IS_DRAFT=$(echo "$PR_DATA" | jq -r '.draft')

          # Draft PR인 경우 알림을 보내지 않습니다.
          if [[ "$IS_DRAFT" == "true" ]]; then
            echo "This is a draft PR. No notification will be sent."
            exit 0
          fi

          PR_AUTHOR=$(echo "$PR_DATA" | jq -r '.user.login')
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title')
          PR_HTML_URL=$(echo "$PR_DATA" | jq -r '.html_url')

          # ----------------------------------------------------------------
          # 3. 다음 스텝으로 전달할 결과값(outputs) 설정
          # ----------------------------------------------------------------
          echo "event_type=$EVENT_TYPE" >> $GITHUB_OUTPUT
          echo "pr_title<<EOF" >> $GITHUB_OUTPUT; echo "$PR_TITLE" >> $GITHUB_OUTPUT; echo "EOF" >> $GITHUB_OUTPUT
          echo "pr_author=$PR_AUTHOR" >> $GITHUB_OUTPUT
          echo "comment_author=$COMMENT_AUTHOR" >> $GITHUB_OUTPUT
          echo "pr_url=$PR_HTML_URL" >> $GITHUB_OUTPUT
          echo "comment_url=$COMMENT_HTML_URL" >> $GITHUB_OUTPUT
          echo "comment_body<<EOF" >> $GITHUB_OUTPUT; echo "$COMMENT_BODY" >> $GITHUB_OUTPUT; echo "EOF" >> $GITHUB_OUTPUT

      - name: Map GitHub users to Slack IDs
        id: map-users
        # 'prepare' 단계에서 알림을 보내기로 결정한 경우에만 이 단계를 실행합니다.
        if: steps.prepare.outputs.event_type != ''
        run: |
          # GitHub ID와 Slack 멤버 ID를 매핑합니다.
          # Slack 멤버 ID는 프로필 보기 -> ... -> 멤버 ID 복사 로 얻을 수 있습니다.
          declare -A GH_TO_SLACK_MAP
          GH_TO_SLACK_MAP["Jindnjs"]="${{ secrets.SLACK_USER_JIN }}"
          GH_TO_SLACK_MAP["LJY981008"]="${{ secrets.SLACK_USER_JUN }}"
          GH_TO_SLACK_MAP["taeung515"]="${{ secrets.SLACK_USER_TAE }}"
          GH_TO_SLACK_MAP["easter1201"]="${{ secrets.SLACK_USER_DOY }}"
          GH_TO_SLACK_MAP["kcc5107"]="${{ secrets.SLACK_USER_GU }}"
          GH_TO_SLACK_MAP["DG0702"]="${{ secrets.SLACK_USER_DONG }}"

          PR_AUTHOR="${{ steps.prepare.outputs.pr_author }}"
          COMMENT_AUTHOR="${{ steps.prepare.outputs.comment_author }}"
          ORIGINAL_COMMENT_AUTHOR="${{ steps.prepare.outputs.original_comment_author }}"

          map_user() {
            local github_user=$1
            local slack_id="${GH_TO_SLACK_MAP[$github_user]}"
            if [ -z "$slack_id" ]; then
              echo "$github_user" # 매핑 정보가 없으면 GitHub ID를 그대로 사용
            else
              echo "<@$slack_id>" # 매핑 정보가 있으면 Slack 태그
            fi
          }

          echo "pr_author_slack=$(map_user "$PR_AUTHOR")" >> $GITHUB_OUTPUT
          echo "comment_author_slack=$(map_user "$COMMENT_AUTHOR")" >> $GITHUB_OUTPUT
          echo "original_comment_author_slack=$(map_user "$ORIGINAL_COMMENT_AUTHOR")" >> $GITHUB_OUTPUT

      - name: Send Slack Message
        # 'prepare' 단계에서 알림을 보내기로 결정한 경우에만 이 단계를 실행합니다.
        if: steps.prepare.outputs.event_type != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_BOT_TEST }}
          EVENT_TYPE: ${{ steps.prepare.outputs.event_type }}
          PR_TITLE: ${{ steps.prepare.outputs.pr_title }}
          PR_URL: ${{ steps.prepare.outputs.pr_url }}
          COMMENT_URL: ${{ steps.prepare.outputs.comment_url }}
          COMMENT_BODY: ${{ steps.prepare.outputs.comment_body }}
          ORIGINAL_COMMENT_BODY: ${{ steps.prepare.outputs.original_comment_body }}
          PR_AUTHOR_SLACK: ${{ steps.map-users.outputs.pr_author_slack }}
          COMMENT_AUTHOR_SLACK: ${{ steps.map-users.outputs.comment_author_slack }}
          ORIGINAL_COMMENT_AUTHOR_SLACK: ${{ steps.map-users.outputs.original_comment_author_slack }}
        run: |
          # Slack 메시지에서 줄바꿈 등을 올바르게 처리하기 위해 변수를 JSON 문자열로 이스케이프합니다.
          escape_json() {
            echo -n "$1" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\n/\\n/g'
          }

          PR_TITLE_ESCAPED=$(escape_json "$PR_TITLE")
          COMMENT_BODY_ESCAPED=$(escape_json "$COMMENT_BODY")
          ORIGINAL_COMMENT_BODY_ESCAPED=$(escape_json "$ORIGINAL_COMMENT_BODY")

          # 이벤트 타입에 따라 다른 메시지를 구성합니다.
          if [[ "$EVENT_TYPE" == "approved" ]]; then
            TEXT="✅ *PR 승인* ✅\n\n*PR:* <$PR_URL|$PR_TITLE_ESCAPED>\n*작성자:* $PR_AUTHOR_SLACK\n*승인자:* $COMMENT_AUTHOR_SLACK"
            if [[ -n "$COMMENT_BODY" ]]; then
              TEXT="$TEXT\n*코멘트:*\n> $COMMENT_BODY_ESCAPED"
            fi
          elif [[ "$EVENT_TYPE" == "changes_requested" ]]; then
            TEXT="⚠️ *PR 변경 요청* ⚠️\n\n*PR:* <$PR_URL|$PR_TITLE_ESCAPED>\n*작성자:* $PR_AUTHOR_SLACK\n*요청자:* $COMMENT_AUTHOR_SLACK"
            if [[ -n "$COMMENT_BODY" ]]; then
              TEXT="$TEXT\n*코멘트:*\n> $COMMENT_BODY_ESCAPED"
            fi
          elif [[ "$EVENT_TYPE" == "reply" ]]; then
            TEXT="💬 *댓글에 답글이 달렸습니다*\n\n*PR:* <$PR_URL|$PR_TITLE_ESCAPED>\n\n*원 댓글:* ($ORIGINAL_COMMENT_AUTHOR_SLACK)\n> $ORIGINAL_COMMENT_BODY_ESCAPED\n\n*답글:* ($COMMENT_AUTHOR_SLACK)\n> <$COMMENT_URL|답글 보기>\n> $COMMENT_BODY_ESCAPED"
          else # "comment"
            TEXT="💬 *새로운 리뷰 요청이 있습니다*\n\n*PR:* <$PR_URL|$PR_TITLE_ESCAPED>\n*작성자:* $PR_AUTHOR_SLACK\n*리뷰어:* $COMMENT_AUTHOR_SLACK\n*코멘트:*\n> <$COMMENT_URL|댓글 보기>\n> $COMMENT_BODY_ESCAPED"
          fi

          # 최종 메시지를 JSON 페이로드로 만듭니다.
          JSON_PAYLOAD="{\"text\": \"$TEXT\"}"

          # Slack으로 메시지를 전송합니다.
          curl -X POST -H 'Content-type: application/json' --data "$JSON_PAYLOAD" $SLACK_WEBHOOK_URL
