# API ì´ë¯¸ì§€ë¥¼ ECRì— ë°°í¬í•˜ê³  ECS ì„œë¹„ìŠ¤ë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” íŒŒì´í”„ë¼ì¸
name: Deploy API to ECS

# main ë¸Œëœì¹˜ì— ë³‘í•©ë  ë•Œ ì‹¤í–‰
on:
  push:
    branches: [ "main" ]

# ì›Œí¬í”Œë¡œìš°ê°€ í•´ì•¼ í•  ì‘ì—…(job)ë“¤ì„ ì •ì˜í•¨.
jobs:
  # "build-and-deploy"ë¼ëŠ” ì´ë¦„ì˜ ì‘ì—…ì„ í•˜ë‚˜ ë§Œë“¤ì—ˆìŒ.
  build-and-deploy:
    # ì´ ì‘ì—…ì€ GitHubì´ ì œê³µí•˜ëŠ” ìµœì‹  ìš°ë¶„íˆ¬ ê°€ìƒë¨¸ì‹ ì—ì„œ ëŒì•„ê°.
    runs-on: ubuntu-latest

    # í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆë“¤ ì„¤ì •
    services:
      # PostgreSQL ì„œë¹„ìŠ¤
      postgres-test:
        image: postgres:16
        env:
          POSTGRES_USER: ljy
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready --host=localhost --user=ljy --dbname=testdb"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      # Redis ì„œë¹„ìŠ¤
      redis-test:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      # MongoDB ì„œë¹„ìŠ¤
      mongodb-test:
        image: mongo:7
        env:
          MONGO_INITDB_ROOT_USERNAME: test_user
          MONGO_INITDB_ROOT_PASSWORD: test_password
          MONGO_INITDB_DATABASE: test_survey_db
        ports:
          - 27017:27017
        options: >-
          --health-cmd="mongosh mongodb://test_user:test_password@localhost:27017/test_survey_db?authSource=admin --eval 'db.adminCommand(\"ping\")'"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    # ì´ ì‘ì—…ì´ ìˆ˜í–‰í•  ë‹¨ê³„(step)ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•¨.
    steps:
      # 1ë‹¨ê³„: ì½”ë“œ ë‚´ë ¤ë°›ê¸°
      - name: Checkout
        uses: actions/checkout@v3

      # 2ë‹¨ê³„: ìë°”(JDK) ì„¤ì¹˜
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # 3ë‹¨ê³„: gradlew íŒŒì¼ì— ì‹¤í–‰ ê¶Œí•œ ì£¼ê¸°
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
      
      # 4ë‹¨ê³„: ì„œë¹„ìŠ¤ ì»¨í…Œì´ë„ˆë“¤ ì¤€ë¹„ ëŒ€ê¸°
      - name: Wait for services to be ready
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U ljy -d testdb; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done
          
          echo "Waiting for Redis to be ready..."
          for i in {1..30}; do
            if redis-cli -h localhost -p 6379 ping; then
              echo "Redis is ready!"
              break
            fi
            echo "Waiting for Redis... ($i/30)"
            sleep 2
          done
          
          echo "Waiting for MongoDB to be ready..."
          for i in {1..30}; do
            if mongosh mongodb://test_user:test_password@localhost:27017/test_survey_db?authSource=admin --eval "db.adminCommand('ping')" --quiet; then
              echo "MongoDB is ready!"
              break
            fi
            echo "Waiting for MongoDB... ($i/30)"
            sleep 2
          done
        
      # 5ë‹¨ê³„: Gradleë¡œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
      - name: Test with Gradle
        run: ./gradlew test
        env:
          SPRING_PROFILES_ACTIVE: test
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb
          SPRING_DATASOURCE_USERNAME: ljy
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          SECRET_KEY: test-secret-key-for-testing-only
          ACTION_REDIS_HOST: localhost
          ACTION_REDIS_PORT: 6379
          MONGODB_URI: mongodb://test_user:test_password@localhost:27017/test_survey_db?authSource=admin
          MONGODB_DATABASE: test_survey_db

      # 6ë‹¨ê³„: í”„ë¡œì íŠ¸ ë¹Œë“œ
      - name: Build with Gradle
        run: ./gradlew build

      # 7ë‹¨ê³„: AWS ìê²© ì¦ëª… êµ¬ì„±
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 8ë‹¨ê³„: ECR ë¡œê·¸ì¸
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # 9ë‹¨ê³„: Docker ì´ë¯¸ì§€ íƒœê·¸ ìƒì„± (íƒ€ì„ìŠ¤íƒ¬í”„ + ì»¤ë°‹ í•´ì‹œ)
      - name: Generate image tag
        id: image-tag
        run: |
          echo "IMAGE_TAG=$(date +%Y%m%d%H%M%S)-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      # 10ë‹¨ê³„: Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° ECRì— í‘¸ì‹œ
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.IMAGE_TAG }}
        run: |
          # ì´ë¯¸ì§€ ë¹Œë“œ
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # ECRì— í‘¸ì‹œ
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # ì¶œë ¥ ë³€ìˆ˜ ì„¤ì •
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # 11ë‹¨ê³„: ECS íƒœìŠ¤í¬ ì •ì˜ ì—…ë°ì´íŠ¸
      - name: Update ECS task definition
        id: update-task-def
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.IMAGE_TAG }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION }}
        run: |
          # í˜„ì¬ íƒœìŠ¤í¬ ì •ì˜ ê°€ì ¸ì˜¤ê¸°
          aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION \
            --query taskDefinition --output json > task-def.json
          
          # ìƒˆë¡œìš´ ì´ë¯¸ì§€ URIë¡œ íƒœìŠ¤í¬ ì •ì˜ ì—…ë°ì´íŠ¸
          NEW_IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # jqë¥¼ ì‚¬ìš©í•˜ì—¬ ì»¨í…Œì´ë„ˆ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
          jq --arg IMAGE_URI "$NEW_IMAGE_URI" \
            '.containerDefinitions[0].image = $IMAGE_URI | 
             del(.taskDefinitionArn) | 
             del(.revision) | 
             del(.status) | 
             del(.requiresAttributes) | 
             del(.placementConstraints) | 
             del(.compatibilities) | 
             del(.registeredAt) | 
             del(.registeredBy)' \
            task-def.json > updated-task-def.json

      # 12ë‹¨ê³„: ECS ì„œë¹„ìŠ¤ ì—…ë°ì´íŠ¸
      - name: Deploy to Amazon ECS
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION }}
        run: |
          # ìƒˆë¡œìš´ íƒœìŠ¤í¬ ì •ì˜ ë“±ë¡
          aws ecs register-task-definition --cli-input-json file://updated-task-def.json
          
          # ì„œë¹„ìŠ¤ ì—…ë°ì´íŠ¸
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --force-new-deployment

      # 13ë‹¨ê³„: ë°°í¬ ìƒíƒœ í™•ì¸
      - name: Wait for service deployment
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
        run: |
          echo "ë°°í¬ ìƒíƒœ í™•ì¸ ì¤‘..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --cli-read-timeout 1200 \
            --cli-connect-timeout 60
          
          echo "ğŸ‰ API ì„œë¹„ìŠ¤ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°í¬ë˜ì—ˆìŠµë‹ˆë‹¤!"
