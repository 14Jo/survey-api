# API 이미지를 ECR에 배포하고 ECS 서비스를 업데이트하는 파이프라인
name: Deploy API to ECS

# main 브랜치에 병합될 때 실행
on:
  push:
    branches: [ "main" ]

# 워크플로우가 해야 할 작업(job)들을 정의함.
jobs:
  # "build-and-deploy"라는 이름의 작업을 하나 만들었음.
  build-and-deploy:
    # 이 작업은 GitHub이 제공하는 최신 우분투 가상머신에서 돌아감.
    runs-on: ubuntu-latest

    # 테스트를 위한 서비스 컨테이너들 설정
    services:
      # PostgreSQL 서비스
      postgres-test:
        image: postgres:16
        env:
          POSTGRES_USER: ljy
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: testdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready --host=localhost --user=ljy --dbname=testdb"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      # Redis 서비스
      redis-test:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

      # MongoDB 서비스
      mongodb-test:
        image: mongo:7
        env:
          MONGO_INITDB_ROOT_USERNAME: test_user
          MONGO_INITDB_ROOT_PASSWORD: test_password
          MONGO_INITDB_DATABASE: test_survey_db
        ports:
          - 27017:27017
        options: >-
          --health-cmd="mongosh mongodb://test_user:test_password@localhost:27017/test_survey_db?authSource=admin --eval 'db.adminCommand(\"ping\")'"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    # 이 작업이 수행할 단계(step)들을 순서대로 나열함.
    steps:
      # 1단계: 코드 내려받기
      - name: Checkout
        uses: actions/checkout@v3

      # 2단계: 자바(JDK) 설치
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      # 3단계: gradlew 파일에 실행 권한 주기
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew
      
      # 4단계: 서비스 컨테이너들 준비 대기
      - name: Wait for services to be ready
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U ljy -d testdb; then
              echo "PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done
          
          echo "Waiting for Redis to be ready..."
          for i in {1..30}; do
            if redis-cli -h localhost -p 6379 ping; then
              echo "Redis is ready!"
              break
            fi
            echo "Waiting for Redis... ($i/30)"
            sleep 2
          done
          
          echo "Waiting for MongoDB to be ready..."
          for i in {1..30}; do
            if mongosh mongodb://test_user:test_password@localhost:27017/test_survey_db?authSource=admin --eval "db.adminCommand('ping')" --quiet; then
              echo "MongoDB is ready!"
              break
            fi
            echo "Waiting for MongoDB... ($i/30)"
            sleep 2
          done
        
      # 5단계: Gradle로 테스트 실행
      - name: Test with Gradle
        run: ./gradlew test
        env:
          SPRING_PROFILES_ACTIVE: test
          SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/testdb
          SPRING_DATASOURCE_USERNAME: ljy
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          SECRET_KEY: test-secret-key-for-testing-only
          ACTION_REDIS_HOST: localhost
          ACTION_REDIS_PORT: 6379
          MONGODB_URI: mongodb://test_user:test_password@localhost:27017/test_survey_db?authSource=admin
          MONGODB_DATABASE: test_survey_db

      # 6단계: 프로젝트 빌드
      - name: Build with Gradle
        run: ./gradlew build

      # 7단계: AWS 자격 증명 구성
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 8단계: ECR 로그인
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # 9단계: Docker 이미지 태그 생성 (타임스탬프 + 커밋 해시)
      - name: Generate image tag
        id: image-tag
        run: |
          echo "IMAGE_TAG=$(date +%Y%m%d%H%M%S)-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "TIMESTAMP=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      # 10단계: Docker 이미지 빌드 및 ECR에 푸시
      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.IMAGE_TAG }}
        run: |
          # 이미지 빌드
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # ECR에 푸시
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # 출력 변수 설정
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # 11단계: ECS 태스크 정의 업데이트
      - name: Update ECS task definition
        id: update-task-def
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.IMAGE_TAG }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION }}
        run: |
          # 현재 태스크 정의 가져오기
          aws ecs describe-task-definition --task-definition $ECS_TASK_DEFINITION \
            --query taskDefinition --output json > task-def.json
          
          # 새로운 이미지 URI로 태스크 정의 업데이트
          NEW_IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          
          # jq를 사용하여 컨테이너 이미지 업데이트
          jq --arg IMAGE_URI "$NEW_IMAGE_URI" \
            '.containerDefinitions[0].image = $IMAGE_URI | 
             del(.taskDefinitionArn) | 
             del(.revision) | 
             del(.status) | 
             del(.requiresAttributes) | 
             del(.placementConstraints) | 
             del(.compatibilities) | 
             del(.registeredAt) | 
             del(.registeredBy)' \
            task-def.json > updated-task-def.json

      # 12단계: ECS 서비스 업데이트
      - name: Deploy to Amazon ECS
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
          ECS_TASK_DEFINITION: ${{ secrets.ECS_TASK_DEFINITION }}
        run: |
          # 새로운 태스크 정의 등록
          aws ecs register-task-definition --cli-input-json file://updated-task-def.json
          
          # 서비스 업데이트
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --force-new-deployment

      # 13단계: 배포 상태 확인
      - name: Wait for service deployment
        env:
          ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
          ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
        run: |
          echo "배포 상태 확인 중..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --cli-read-timeout 1200 \
            --cli-connect-timeout 60
          
          echo "🎉 API 서비스가 성공적으로 배포되었습니다!"
